I"∫<h1 id="discontinuity-attributes">Discontinuity Attributes</h1>
<p>modified from <a href="https://github.com/seg/tutorials">Joe Kington‚Äôs Jupyter notebook</a></p>

<p>title: ‚ÄúDiscontinuity attributes‚Äù
date: 2020-07-30
tags: [post, geo, field, lab]
header:
  image: ‚Äú/images/DSC_0006.JPG‚Äù
mathjax: ‚Äútrue‚Äù</p>

<h2 id="introduction">Introduction</h2>

<p>Discontinuity calculations, also called coherence or semblance, are some of the most commonly used seismic attributes. They measure the amount of similarity between adjacent seismic traces. However, there are several different types of discontinuity estimates and a plethora of names for similar attributes.</p>

<h2 id="cross-correlation">Cross-correlation</h2>
<p>The earliest discontinuity algorithm was developed by Bahorich and Farmer (1995) and used the maximum cross-correlation value of three traces.  Each trace is correlated with a ‚Äúmoving-window‚Äù subset of two neighboring traces (Figures 1B and 2B). A complete implementation is given in the accompanying notebook, but we‚Äôll skip it here for brevity. Bahorich and Farmer coined the term ‚Äúcoherence‚Äù for the attribute, based on its conceptual similarity to pre-stack methods for estimating stacking velocities (e.g. Taner and Koehler, 1969).  While this exact approach is computationally expensive and not widely used today, it provides a starting point to understand later algorithms.</p>

<p>Cross-correlation approach to an arbitrary number of input traces is also referred to as ‚Äúsemblance-based coherence‚Äù. As an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def moving_window(data, func, window):
  wrapped = lambda x: func(x.reshape(window))
  return scipy.ndimage.generic_filter(data,
                                      wrapped,
                                      window)

def marfurt_semblance(region):
  # Stack traces in 3D region into 2D array
  region = region.reshape(-1, region.shape[-1])
  ntraces, nsamples = region.shape
  square_sums = np.sum(region, axis=0)**2
  sum_squares = np.sum(region**2, axis=0)
  c = square_sums.sum() / square_sums.sum()
  return c / ntraces

result = moving_window(seismic_data,
                       marfurt_semblance,
                       (3, 3, 9))
</code></pre></div></div>

<h2 id="removing-amplitude-sensitivity">Removing Amplitude Sensitivity</h2>

<p>Methods to compute discontinuity are sensitive to lateral differences in amplitude as well as in phase. While this is desirable for detecting stratigraphic features, differences due amplitude can obscure subtle structural features. <em>Eigenstructure-based coherence</em> is an implementation that is sensitive only to lateral changes in phase of the input waveforms.</p>

<p>Eigenstructure-based coherence (Gersztenkorn and Marfurt, 1999) computes the covariance matrix of the input region, similar to the previous example. However, it uses the ratio of the largest eigenvalue of the covariance matrix to the sum of the eigenvalues:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def gersztenkorn(region):
  # Stack traces in 3D region into 2D array
  region = region.reshape(-1, region.shape[-1])

  # Calculate eigenvalues of covariance matrix
  cov = region.dot(region.T)
  vals = np.linalg.eigvalsh(cov)
  return vals.max() / vals.sum()

result = moving_window(seismic_data,
                       gersztenkorn,
                       (3, 3, 9))
</code></pre></div></div>

<p>Conceptually, this is similar to treating each seismic trace within the moving window as a separate dimension and calculating how well the resulting point cloud is fit by a plane.</p>

<h2 id="gradient-changes-instead-of-trace-similarity">Gradient Changes Instead of Trace Similarity</h2>

<p>The structure tensor measures how the gradient of each dimension co-varies locally. A number of useful attributes can be computed from the ratios of the eigenvalues of the structure tensor, one of which is a measure of how planar the data is locally, which we‚Äôll refer to as GST coherence.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from scipy.ndimage import gaussian_filter1d

def gradients(seismic, sigma):
  grads = []
  for axis in range(3):
    grad = gaussian_filter1d(seismic, sigma,
	                         axis=axis, order=1)
    grads.append(grad[..., np.newaxis])
  return np.concatenate(grads, axis=3)

def gst_coherence_calc(region):
  region = region.reshape(-1, 3)
  gst = region.T.dot(region)
  eigs = np.sort(np.linalg.eigvalsh(gst))[::-1]
  return (eigs[0]-eigs[1]) / (eigs[0]+eigs[1])

def gst_coherence(seismic, window, sigma=1):
  grad = gradients(seismic, sigma)
  return moving_window4d(grad_array,
                         window,
                         gst_coherence_calc)
</code></pre></div></div>

<p>Because GST coherence measures change in the local slope of the data, it is more closely related to curvature attributes than to the other discontinuity attributes. Therefore, it can reveal different features than discontinuity attributes that compare waveform similarity, but tends to show thicker regions of discontinuity around faults.</p>

<h2 id="final-remarks">Final Remarks</h2>

<p>Discontinuity attributes are a fundamental part of an interpreter‚Äôs toolkit when working with 3D data. While most interpreters are familiar with using discontinuity attributes, few are familiar with how they‚Äôre implemented or the differences between similar attributes. Hopefully the accompanying Jupyter notebook and this brief tutorial helps clear up some implementation details and inspires you to attempt new variants on well-known discontinuity attributes.</p>

<h2 id="figures">Figures</h2>

<p><img src="images/figure_1.png" alt="Figure 1" /></p>

<p><strong>Figure 1</strong>: A comparison of the discontinuity algorithms discussed using the Penebscot 3D seismic dataset (Nova Scotia Department of Energy, 1992).</p>

<p><img src="images/figure_2.png" alt="Figure 2" /></p>

<p><strong>Figure 2</strong>: A visual explanation of the differences between the discontinuity algorithms discussed using only two traces. ‚ÄúC‚Äù indicates the calculated coherence value.</p>
:ET